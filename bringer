#!/bin/bash

# todo: fix nesting; remove last for loop and IFS, ...
# remark: arrays seem to be of no use in this script because they
# would require programming an alternative to "sort"
# todo: re-implement "bringing", implement closing and history feature

main()
    {
	echoExtraEntries()
	{
	    echoSortLines()
	    {
		echoSortLinesForDesktop()
		{
		    echoSortCommandsOnOneLine()
		    {
			declare firstDone
			while read command
			do
			    if [ ! $firstDone ] 
			    then
				firstDone=dummy
			    else
				echo -n " --- "
			    fi
			    echo -n "$command"
			done
		    }
		    
		    prefixSuffix()
		    {
			while read pair
			do
    			    echo "$1:$pair:$2"
			done
		    }
		    
		    declare commandWindowPairs=`echo -e "$1" | sort`
		    declare sortCommands=`echo "$commandWindowPairs" | cut -d : -f 1 | echoSortCommandsOnOneLine`
		    echo "$commandWindowPairs" | prefixSuffix "$sortCommands" "$2"
		}
		
		getCommand()
		{
		    ps -p $1 -o command= | sed "s/^[^ ]*\///"
		}
		
		processWindowLines()
		{
		    declare -i lastDesktop=-1
		    declare commandWindowPairs
		    declare -i window
		    declare -i desktop
		    declare -i pid
		    declare command
		    while read line
		    do
			window=`echo "$line" | cut -d " " -f 1`
			desktop=`echo "$line" | cut -d " " -f 3`
			pid=`echo "$line" | cut -d " " -f 4`
        # title=`echo "$line" | cut -d " " -f 1,2,3,4,5,6 --complement` 
			command=`getCommand $pid`
			if [ $desktop -ne $lastDesktop ]
			then
			    if [ $lastDesktop -ne -1 ]
			    then
				echoSortLinesForDesktop "$commandWindowPairs" "$lastDesktop"
 			    fi
			    commandWindowPairs=$command:$window
			    lastDesktop=$desktop
			else
			    commandWindowPairs="$commandWindowPairs\n$command:$window"
			fi
		    done
		    echoSortLinesForDesktop "$commandWindowPairs" "$lastDesktop"
		}

		wmctrl -lp | processWindowLines
	    }
	    
	    declare command
	    declare -i window
	    declare -i desktop
	    declare commands
	    declare lastCommands
	    declare gotoLines=""
	    declare -i visibleDesktop=`wmctrl -d | grep \* | cut -d " " -f 1`
	    declare -i counter=1
	    for line in `echoSortLines | sort` 
	    do 
		command=`echo "$line" | cut -d : -f 2`
		window=`echo "$line" | cut -d : -f 3`
		desktop=`echo "$line" | cut -d : -f 4`
		commands=`echo "$line" | cut -d : -f 1`
		if [ "$commands" != "$lastCommands" ]
		then
		    if [ -n "$gotoLines" ]
		    then
			gotoLines="$gotoLines\n"
		    fi
		    gotoLines="$gotoLines$counter goto $window "
 		    if [ $desktop -eq $visibleDesktop ] 
		    then
			gotoLines="$gotoLines*"
		    fi
		    gotoLines="$gotoLines$commands"
		    counter=$counter+1    
		fi
		lastCommands=$commands
	    done
	    echo -e "$gotoLines"
#echo "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------$bringLines"
#"$bringLines" on extra line causes trouble for some reason 
#echo "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
	}
	
	IFS=$'\n' # so that the e.g. for loop below uses newline as separator
	declare line=`(echoExtraEntries;dmenu_path) | dmenu -i -l 13` 
	declare -i window
	
	if echo "$line" | grep goto
	then
	    window=`echo "$line" | cut -d " " -f 3`
	    wmctrl -ia $window
	else
	    echo "$line" | grep bring
	    
	    if echo "$line" | grep bring 
	    then
		window=`echo "$line" | cut -d " " -f 3`
		wmctrl -iR $window
	    else
		exec $line
	    fi
	fi
    }

main
