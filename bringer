#!/bin/bash

# remark: arrays seem to be of no use in this script because they
# would require programming an alternative to "sort"
# todo: re-implement "bringing", implement closing and history feature

getCommand()
{
    ps -p $1 -o command= | sed "s/^[^ ]*\///"
}

appendSortLines()
{
    declare commandWindowPairs=`echo -e "$1" | sort`
    declare sortCommands
    declare command
    for pair in $commandWindowPairs
    do
	command=`echo "$pair" | cut -d : -f 1`
	if [ ! $sortCommands ] 
	then
	    sortCommands=$command
	else
	    sortCommands="$sortCommands --- $command"
	fi
    done
    for pair in $commandWindowPairs
    do
	echo "$sortCommands:$pair:$2" # $2 is the desktop
    done
}

getSortLines()
{
    declare -i lastDesktop=-1
    declare commandWindowPairs
    declare -i window
    declare -i desktop
    declare -i pid
    declare command
    for line in `wmctrl -lp`
    do 
	window=`echo "$line" | cut -d " " -f 1`
	desktop=`echo "$line" | cut -d " " -f 3`
        pid=`echo "$line" | cut -d " " -f 4`
        # title=`echo "$line" | cut -d " " -f 1,2,3,4,5,6 --complement` 
	command=`getCommand $pid`
	if [ $desktop -ne $lastDesktop ]
	then
	    if [ $lastDesktop -ne -1 ]
	    then
		appendSortLines "$commandWindowPairs" "$lastDesktop"
 	    fi
	    commandWindowPairs=$command:$window
	    lastDesktop=$desktop
	else
	    commandWindowPairs="$commandWindowPairs\n$command:$window"
	fi
    done
    appendSortLines "$commandWindowPairs" "$lastDesktop"
}

getWindows()
{
    declare command
    declare -i window
    declare -i desktop
    declare commands
    declare lastCommands
    declare gotoLines=""
    declare -i visibleDesktop=`wmctrl -d | grep \* | cut -d " " -f 1`
    declare -i counter=1
    for line in `getSortLines | sort` 
    do 
	command=`echo "$line" | cut -d : -f 2`
	window=`echo "$line" | cut -d : -f 3`
	desktop=`echo "$line" | cut -d : -f 4`
	commands=`echo "$line" | cut -d : -f 1`
	if [ "$commands" != "$lastCommands" ]
	then
	    if [ -n "$gotoLines" ]
	    then
		gotoLines="$gotoLines\n"
	    fi
	    gotoLines="$gotoLines$counter goto $window "
 	    if [ $desktop -eq $visibleDesktop ] 
	    then
		gotoLines="$gotoLines*"
	    fi
	    gotoLines="$gotoLines$commands"
	    counter=$counter+1    
	fi
	lastCommands=$commands
    done
    echo -e "$gotoLines"
#echo "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------$bringLines"
#"$bringLines" on extra line causes trouble for some reason 
#echo "-------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
}

main()
    {
	IFS=$'\n' # so that the e.g. for loop below uses newline as separator
	declare line=`(getWindows;dmenu_path) | dmenu -i -l 13` 
	declare -i window
	
	if echo "$line" | grep goto
	then
	    window=`echo "$line" | cut -d " " -f 3`
	    wmctrl -ia $window
	else
	    echo "$line" | grep bring
	    
	    if echo "$line" | grep bring 
	    then
		window=`echo "$line" | cut -d " " -f 3`
		wmctrl -iR $window
	    else
		exec $line
	    fi
	fi
    }

main
